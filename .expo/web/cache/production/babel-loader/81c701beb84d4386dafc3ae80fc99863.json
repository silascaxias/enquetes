{"ast":null,"code":"var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _objectWithoutProperties2=_interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));var _toConsumableArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _get2=_interopRequireDefault(require(\"@babel/runtime/helpers/get\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var _hammerjs=_interopRequireDefault(require(\"@egjs/hammerjs\"));var _constants=require(\"./constants\");var _Errors=require(\"./Errors\");var _DraggingGestureHandler=_interopRequireDefault(require(\"./DraggingGestureHandler\"));var _utils=require(\"./utils\");function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return true;}catch(e){return false;}}var FlingGestureHandler=function(_DraggingGestureHandl){(0,_inherits2.default)(FlingGestureHandler,_DraggingGestureHandl);var _super=_createSuper(FlingGestureHandler);function FlingGestureHandler(){(0,_classCallCheck2.default)(this,FlingGestureHandler);return _super.apply(this,arguments);}(0,_createClass2.default)(FlingGestureHandler,[{key:\"onGestureActivated\",value:function onGestureActivated(event){this.sendEvent((0,_extends2.default)({},event,{eventType:_hammerjs.default.INPUT_MOVE,isFinal:false,isFirst:true}));this.isGestureRunning=false;this.hasGestureFailed=false;this.sendEvent((0,_extends2.default)({},event,{eventType:_hammerjs.default.INPUT_END,isFinal:true}));}},{key:\"onRawEvent\",value:function onRawEvent(ev){var _this=this;(0,_get2.default)((0,_getPrototypeOf2.default)(FlingGestureHandler.prototype),\"onRawEvent\",this).call(this,ev);if(this.hasGestureFailed){return;}if(ev.isFinal){setTimeout(function(){if(_this.isGestureRunning){_this.cancelEvent(ev);}});}else if(!this.hasGestureFailed&&!this.isGestureRunning){var gesture=this.hammer.get(this.name);if(gesture.options.enable(gesture,ev)){this.onStart(ev);this.sendEvent(ev);}}}},{key:\"getHammerConfig\",value:function getHammerConfig(){return{pointers:this.config.numberOfPointers,direction:this.getDirection()};}},{key:\"getTargetDirections\",value:function getTargetDirections(direction){var directions=[];if(direction&_constants.Direction.RIGHT){directions.push(_hammerjs.default.DIRECTION_RIGHT);}if(direction&_constants.Direction.LEFT){directions.push(_hammerjs.default.DIRECTION_LEFT);}if(direction&_constants.Direction.UP){directions.push(_hammerjs.default.DIRECTION_UP);}if(direction&_constants.Direction.DOWN){directions.push(_hammerjs.default.DIRECTION_DOWN);}return directions;}},{key:\"getDirection\",value:function getDirection(){var _this$getConfig=this.getConfig(),direction=_this$getConfig.direction;var directions=[];if(direction&_constants.Direction.RIGHT){directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);}if(direction&_constants.Direction.LEFT){directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);}if(direction&_constants.Direction.UP){directions.push(_hammerjs.default.DIRECTION_VERTICAL);}if(direction&_constants.Direction.DOWN){directions.push(_hammerjs.default.DIRECTION_VERTICAL);}directions=(0,_toConsumableArray2.default)(new Set(directions));if(directions.length===0)return _hammerjs.default.DIRECTION_NONE;if(directions.length===1)return directions[0];return _hammerjs.default.DIRECTION_ALL;}},{key:\"isGestureEnabledForEvent\",value:function isGestureEnabledForEvent(_ref,recognizer,_ref2){var minPointers=_ref.minPointers,maxPointers=_ref.maxPointers,numberOfPointers=_ref.numberOfPointers,maxDist=_ref.maxDist,maxDeltaX=_ref.maxDeltaX,maxDeltaY=_ref.maxDeltaY,maxDistSq=_ref.maxDistSq,shouldCancelWhenOutside=_ref.shouldCancelWhenOutside;var pointerLength=_ref2.maxPointers,dx=_ref2.deltaX,dy=_ref2.deltaY,props=(0,_objectWithoutProperties2.default)(_ref2,[\"maxPointers\",\"deltaX\",\"deltaY\"]);var validPointerCount=pointerLength===numberOfPointers;if(!validPointerCount&&this.isGestureRunning){return{failed:true};}return{success:validPointerCount};}},{key:\"updateGestureConfig\",value:function updateGestureConfig(_ref3){var _ref3$numberOfPointer=_ref3.numberOfPointers,numberOfPointers=_ref3$numberOfPointer===void 0?1:_ref3$numberOfPointer,direction=_ref3.direction,props=(0,_objectWithoutProperties2.default)(_ref3,[\"numberOfPointers\",\"direction\"]);if((0,_utils.isnan)(direction)||typeof direction!=='number'){throw new _Errors.GesturePropError('direction',direction,'number');}return(0,_get2.default)((0,_getPrototypeOf2.default)(FlingGestureHandler.prototype),\"updateGestureConfig\",this).call(this,(0,_extends2.default)({numberOfPointers:numberOfPointers,direction:direction},props));}},{key:\"name\",get:function get(){return'swipe';}},{key:\"NativeGestureClass\",get:function get(){return _hammerjs.default.Swipe;}}]);return FlingGestureHandler;}(_DraggingGestureHandler.default);var _default=FlingGestureHandler;exports.default=_default;","map":{"version":3,"sources":["/Users/scaxias/Projetos/Estudos/Enquetes/node_modules/react-native-gesture-handler/web/FlingGestureHandler.js"],"names":["FlingGestureHandler","event","sendEvent","eventType","Hammer","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","ev","setTimeout","cancelEvent","gesture","hammer","get","name","options","enable","onStart","pointers","config","numberOfPointers","direction","getDirection","directions","Direction","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","recognizer","minPointers","maxPointers","maxDist","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","pointerLength","dx","deltaX","dy","deltaY","props","validPointerCount","failed","success","GesturePropError","Swipe","DraggingGestureHandler"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      numberOfPointers,\n      maxDist,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    },\n    recognizer,\n    { maxPointers: pointerLength, deltaX: dx, deltaY: dy, ...props }\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]},"metadata":{},"sourceType":"script"}